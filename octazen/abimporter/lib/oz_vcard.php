<?php
/********************************************************************************
DO NOT EDIT THIS FILE!

VCard Library

You may not reprint or redistribute this code without permission from Octazen Solutions.

Copyright 2009 Octazen Solutions. All Rights Reserved
WWW: http://www.octazen.com
********************************************************************************/

function oz_vcard_unescape ($str) {
 	if ($str==null) return null;
 	$ba2 = '';
 	$n = strlen($str);
 	for ($i=0; $i<$n; $i++) {
		$v = $str[$i];
		if ($v=='\\' && $i+1<$n) {
			$v2 = $str[++$i];
			if ($v2=='r') $ba2.="\r";
			else if ($v2=='n') $ba2.="\n";
			else $ba2.=$v2;
		}
		else {
			$ba2.=$v;
		}
	}
}

function oz_vcard_to_string($ba,$encoding,$charset) {
	if ($encoding!=null) {
		$encoding = strtoupper($encoding);
		if ('QUOTED-PRINTABLE'==$encoding) $ba=quoted_printable_decode($ba);
		else if ('B'==$encoding) $ba=base64_decode($ba);
	}
	
	if ($charset==null) {
		return $ba;
	}
	else {
		$charset = strtoupper($charset);
		if ($charset=='UTF-8' || $charset=='UTF8') return $ba;
		else return iconv($charset,'UTF-8',$ba);
	}
}

function oz_vcard_to_binary ($ba, $encoding) {
	if ($encoding!=null) {
		$encoding = strtoupper($encoding);
		if ('QUOTED-PRINTABLE'==$encoding) return quoted_printable_decode($ba);
		else if ('B'==$encoding) return base64_decode($ba);
	}
	return $ba;
}

function oz_vcard_split ($ba,$delim=',') {
 	$a = array();
 	$n = strlen($ba);
 	$i1 = 0;
	for ($i = 0; $i < $n; $i++) {
		$c = $ba[$i];
		if ($c == '\\') {
			// Skip the next escape char
			if ($i+1 < $n) {
				$i++;
			}
		} else if ($c == $delim) {
		 	$a[]=substr($ba,$i1,$i-$i1);
		 	$i1=$i+1;
		}
	}
	if ($i1 < $n) {
		if ($i1 == 0) $a[]=$ba;
		else $a[]=substr($ba,$i1,$n-$i1);
	}
	return $a;
}

//A class representing a VCard field (content line))
class OzVCardField {
	var $name;
	var $rawValue;
	var $params = array();
	
	function OzVCardField ($rawName, $rawValue) {

		$sa = explode(';',$rawName);
		$this->name = trim($sa[0]);

		// Remainder are parameters
		$n = count($sa);
		for ($i = 1; $i < $n; $i++) {
			$s = $sa[$i];
			$idx = strpos($s,'=');
			if ($idx===false) {
				$this->addParam(trim($s),null);
			}
			else {
				$key = strtoupper(trim(substr($s,0,$idx)));
				$vals = explode(',',substr($s,$idx+1));
				foreach ($vals as $val) {
					$this->addParam($key,trim($val));
				}
			}
		}

		// Add value
		$this->rawValue = $rawValue;
	}


	function addParam($paramName, $value) {
		$paramName = strtoupper($paramName);
		if (isset($this->params[$paramName])) {
		 	$this->params[$paramName][] = $value;
		}
		else {
		 	$a = array();
		 	$a[] = $value;
			$this->params[$paramName] = $a;//array($value);
		}
	}
		
	function hasParam ($paramName) {
		return array_key_exists(strtoupper($paramName),$this->params);
	}
	
	function &getParamValues ($paramName) {
		$paramName = strtoupper($paramName);
		if (isset($this->params[$paramName])) {
			return $this->params[$paramName];
		}
		else {
			return null;
		}
	}
	
	function getFirstParamValue ($paramName) {
		$paramName = strtoupper($paramName);
		if (isset($this->params[$paramName])) {
			$v =& $this->params[$paramName];
			if (count($v)==0) return null;
			else return $v[0];
		}
		else {
			return null;
		}
	}
	
	function getBinaryValue () {
		$encoding = $this->getFirstParamValue('ENCODING');
	 	return oz_vcard_to_binary($this->rawValue,$encoding);
	}
	
	function getStringValue () {
		$encoding = $this->getFirstParamValue('ENCODING');
		$charset = $this->getFirstParamValue('CHARSET');
	 	return oz_vcard_to_string($this->rawValue,$encoding,$charset);
	}
	
	function getStringValues ($delim) {
		$encoding = $this->getFirstParamValue('ENCODING');
		$charset = $this->getFirstParamValue('CHARSET');
		$al = array();
		$a = oz_vcard_split($this->rawValue,$delim);
		foreach ($a as $v)
	 		$al[] = oz_vcard_to_string($v,$encoding,$charset);
		return $al;
	}
}




//Tokenizer to tokenize vcard like formats, returning series of OzVCardField tokens
class OzVCardTokenizer {

	var $src;
	var $len;
	var $pos;
	
	var $previousKey;
	var $previousValue;

	function OzVCardTokenizer($vcf) {
	 	$this->src = $vcf;
	 	$this->pos = 0;
	 	$this->len = strlen($vcf);
	 	$this->previousKey = null;
	 	$this->previousValue = '';
	}
	
	function readUntilCRLF(&$buf) {
	 	$i = $this->pos;
	 	$n = $this->len;
		while ($i<$n) {
			$v = $this->src[$i++];
			if ($v=="\r") continue;
			else if ($v=="\n") break;
			else if ($v=='\\') {
			 	if ($i>=$n) break;
				$v2 = $this->src[$i++];
				if ($v2=='r') $buf.="\r";
				else if ($v2=='n') $buf.="\n";
				else $buf.=$v2;
			}
			else $buf.=$v;
		}
		$this->pos = $i;
	}

	function readUntilColonOrCRLF(&$buf) {
	 	$i = $this->pos;
	 	$n = $this->len;
		while ($i<$n) {
			$v = $this->src[$i++];
			if ($v=="\r") continue;
			else if ($v=="\n") break;
			else if ($v==':') {
				$this->pos = $i;
				return true;	
			}
			else if ($v=='\\') {
			 	if ($i>=$n) break;
				$v2 = $this->src[$i++];
				if ($v2=='r') $buf.="\r";
				else if ($v2=='n') $buf.="\n";
				else $buf.=$v2;
			}
			else $buf.=$v;
		}
		$this->pos = $i;
		return false;
	}


	function next()  {
	 	if ($this->pos < $this->len) {
	 		while ($this->pos < $this->len) {
		 	 	$ba = '';
		 	 	$hitColon = $this->readUntilColonOrCRLF($ba);
		 	 	if (empty($ba)) {
					if ($hitColon) $this->readUntilCRLF($ba);
					continue;
				}
				if ($hitColon) {
					$c = $ba[0];
					if (($c==' ' || $c=='\t') && $this->previousKey!=null) {
						// This is a folded value. The ':' was mistakenly swallowed. Read until hit CRLF/EOF.
					 	$this->previousValue.=substr($ba,1);
					 	$this->previousValue.=':';
					 	$this->readUntilCRLF($this->previousValue);
					}
					else {
						// Dump out previous field if any
						$field = null;
						if ($this->previousKey!=null) 
							$field = new OzVCardField($this->previousKey, $this->previousValue);
						$this->previousKey = $ba;
						$this->previousValue = '';
						$this->readUntilCRLF($this->previousValue);
						
						// In case of Quoted Printable line folding, there is no
						// need for a first whitespace character on the next
						// folded line. (Doesn't obey the requirements for VCard
						// line folding). If last character of previousValue is
						// a '=', then we'll need to continue reading newline
						// again..
						$tmpf = new OzVCardField($this->previousKey, null);
						$enc = $tmpf->getFirstParamValue('ENCODING');
						if ($enc!=null && strtoupper($enc)=='QUOTED-PRINTABLE') {
						 	while ($this->pos < $this->len) {
								$ln = strlen($this->previousValue);
								if ($ln==0 || $this->previousValue[$ln-1]!='=') {
									break;
								}
								$this->previousValue = substr($this->previousValue,0,$ln-1); //or just $this->previousValue.="\r\n";
								$this->readUntilCRLF($this->previousValue);
							}
						}

						if ($field!=null) return $field;
					}
				}
				else {
					$c = $ba[0];
					if (($c==' ' || $c=='\t') && $this->previousKey!=null) {
						// This is a folded value. The ':' was mistakenly swallowed. Read until hit CRLF/EOF.
					 	$this->previousValue.=substr($ba,1);
					}
					else {
						//Junk line
					}
				}
	 		} 
		}
		
		// if reach here, eof is encountered
		if ($this->previousKey != null) {
			$field = new OzVCardField($this->previousKey, $this->previousValue);
			$this->previousKey = null;
			$this->previousValue = '';
			return $field;
		} else {
			return null;
		}
	}
}






/////////////////////////////////////////////////////////////////////////////////////////////


/*



class VCardRecord  {

	var $map = array();


	//Split vcard escaped string values using given delimeter
	function split($str, $delimchar, $unescape=false, $minParts=-1, $paddingValue=nil) {
		$al = array();
		$n = strlen($str);
		$i1 = 0;
		for ($i=0; $i<$n; $i++) {
			$c = $str[$i];
			if ($c=="\\") {
			 	//Skip next escape char
				$i++;
			} 
			else if ($c==$delimchar) {
				$al[] = substr($str,$i1,$i-$i1);
				$i1 = $i+1;
			}
		}
		if ($i1<$n)
			$al[] = substr($str,$i1,$n-$i1);
			
		if ($unescape) {
			$n = count($al);
			for ($i=0; $i<$n; $i++) {
				$al[$i] = $this->unescape($al[$i]);
			}
		}
		
		if ($minParts>=0) {
			$n = count($al);
			while ($n<$minParts) {
				$al[]=$paddingValue;
				$n++;
			}
		}
					
		return $al;
	}
	
	function unescape ($str) {
		$n = strlen($str);
		$sb = '';
		$escaped = false;
		for ($i=0; $i<$n; $i++) {
			$c = $str[$i];
			if ($escaped) {
				if ($c=='n' || $c=='N') $sb.="\r\n";
				else $sb.=$c;
			}
			else {
			 	if ($c=="\\") $escaped=true;
			 	else $sb.=$c;
			}
		}
		return $sb;
	}

	function getTypePart($type) {
		$sa = explode(';',$type,2);
		return $sa[0];
	}

	function add($field, $value) {
	 	$field = strtolower($field);
	 	if (!array_key_exists($field,$this->map))
		 	$this->map[$field] = array();
	 	$vals =& $this->map[$field];
	 	$vals[] = $value;
	}

	function get($field, $unescape=false) {
	 	$field = strtolower($field);
	 	if (!array_key_exists($field,$this->map)) return null;
	 	else {
			$v = $this->map[$field];
			if ($unescape) $v=$this->unescape($v);
			return $v;
		}
	}

	function getFirst($field, $unescape=false) {
	 	$vals =& $this->get($field);
	 	if (empty($vals)) return null;
		$v = $vals[0];
		if ($unescape) $v=$this->unescape($v);
		return $v;
	}

	function clear() {
	 	$this->map = array();
	}

	function remove($field) {
	 	$field = strtolower($field);
	 	unset($this->map[$field]);
	}

	function getFields() {
	 	return array_keys($this->map);
	}
	
	
	function getFieldsByType($type) {
		$type = strtoupper($type);
		$al = array();
	 	$keys = array_keys($this->map);
	 	foreach ($keys as $key) {
	 	 	$type2 = $this->getTypePart($key);
	 	 	if ($type2==$type) {
				$al[] = $key;
			}
		}
		return $al;
	}
}


class VCardParser {

	var $_lines;
	var $_idx;
	var $_count;

	function VCardParser($vcf) {
		$this->_lines = preg_split("/\r?\n/", $vcf);
		$this->_idx = 0;
		$this->_count = count($this->_lines);
	}

	function unescape($str) {
		// No unescaping performed for now
		return $str;
	}

	function next()  {
	 	$inVcard = false;
	 	$rec = null;
		$previousKey = null;
		$previousValue = "";
		while ($this->_idx<$this->_count) {
			$s =& $this->_lines[$this->_idx++];
			if (empty($s)) {
			 	continue;
			} 
			
			if ($inVcard) {
				$c = $s[0];
				if ($c == ' ' || $c == '\t') {
					// This is a folded value
					$previousValue.=substr($s,1);
				} else {
					$i = strpos($s,':');
					if ($i===false) continue;
					
					if ($rec!=null && $previousKey!=null) {
						$vals = VCardRecord::split($previousValue,',');
						foreach ($vals as $val) {
							$rec.add($previousKey,$val);
						}
						$previousKey = null;
					}
						
					$previousKey = trim(substr($s,0,$i));
					$previousValue = ltrim(substr($s,$i+1));
					if ($previousKey=='END' && $previousValue=='VCARD') {
						//Hit end of contact record
						break;
					}
				}
			} else {
				$i = strpos($s,':');
				if ($i===false) continue;
				$key = trim(substr($s,0,$i));
				$value = ltrim(substr($s,$i+1));
				if ($key=='BEGIN' && $value=='VCARD') {
				 	$inVcard = true;
				 	$rec = new VCardRecord;
				 	$previousKey = null;
				 	$previousValue = '';
				}
			}
		}
		return $rec;
	}
}

*/
?>